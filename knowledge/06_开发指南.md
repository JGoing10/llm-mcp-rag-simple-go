# 开发指南

## 项目架构

### 整体架构图
```
┌─────────────────────────────────────────────────────────────┐
│                        用户界面层                            │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   命令行界面     │  │   HTTP API      │  │   Web界面       │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        业务逻辑层                            │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    Agent (代理)                         │ │
│  │  - 查询处理    - 知识管理    - 工具调用    - 对话管理    │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        服务层                               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   ChatClient    │  │ EmbeddingClient │  │   MCPClient     │ │
│  │  - LLM交互      │  │  - 文本嵌入     │  │  - 工具调用     │ │
│  │  - 对话管理     │  │  - 相似度搜索   │  │  - 外部集成     │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
                              │
┌─────────────────────────────────────────────────────────────┐
│                        数据层                               │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐ │
│  │   VectorStore   │  │   ConfigStore   │  │   LogStore      │ │
│  │  - 向量存储     │  │  - 配置管理     │  │  - 日志记录     │ │
│  │  - 文档索引     │  │  - 环境变量     │  │  - 错误追踪     │ │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 核心组件

#### 1. Agent (代理)
- **职责**：协调各个组件，处理用户请求
- **位置**：`internal/agent/agent.go`
- **接口**：
  ```go
  type Agent interface {
      Query(ctx context.Context, query string) (*ChatResponse, error)
      AddKnowledge(ctx context.Context, documents []string) error
      AddMCPClient(name string, client MCPClient) error
      GetMessageHistory() []ChatMessage
      Close() error
  }
  ```

#### 2. ChatClient (聊天客户端)
- **职责**：与大语言模型交互
- **位置**：`internal/chat/openai.go`
- **特性**：
  - 支持多种API服务商
  - 工具调用功能
  - 对话历史管理
  - 流式响应支持

#### 3. EmbeddingRetriever (嵌入检索器)
- **职责**：文本向量化和相似度搜索
- **位置**：`internal/embedding/retriever.go`
- **功能**：
  - 文档嵌入
  - 查询嵌入
  - 相似度检索
  - 缓存管理

#### 4. VectorStore (向量存储)
- **职责**：向量数据存储和搜索
- **位置**：`internal/vectorstore/vectorstore.go`
- **实现**：
  - 内存存储
  - 余弦相似度计算
  - 批量操作支持

#### 5. MCPClient (MCP客户端)
- **职责**：外部工具集成
- **位置**：`internal/mcp/client.go`
- **功能**：
  - 工具发现
  - 工具调用
  - 进程管理
  - 错误处理

## 开发环境设置

### 1. 环境要求
```bash
# Go版本
go version  # 需要 1.21+

# Node.js (用于MCP工具)
node --version  # 需要 16+
npm --version

# Git
git --version
```

### 2. 项目设置
```bash
# 克隆项目
git clone <repository-url>
cd go-llm-mcp-rag

# 安装Go依赖
go mod download

# 安装MCP工具
npm install -g @modelcontextprotocol/server-filesystem
npm install -g @modelcontextprotocol/server-fetch

# 设置开发环境
make dev-setup
```

### 3. IDE配置

#### VS Code
推荐插件：
- Go (官方Go插件)
- Go Test Explorer
- REST Client
- Markdown All in One

配置文件 `.vscode/settings.json`：
```json
{
    "go.useLanguageServer": true,
    "go.formatTool": "goimports",
    "go.lintTool": "golangci-lint",
    "go.testFlags": ["-v"],
    "go.coverOnSave": true
}
```

#### GoLand
- 启用Go Modules支持
- 配置代码格式化
- 设置测试运行配置
- 启用代码覆盖率

## 代码规范

### 1. 命名规范
```go
// 包名：小写，简短，有意义
package agent

// 接口名：名词，首字母大写，通常以-er结尾
type VectorStore interface {}
type EmbeddingRetriever interface {}

// 结构体：名词，首字母大写
type OpenAIClient struct {}
type AgentConfig struct {}

// 函数名：动词开头，驼峰命名
func NewAgent() *Agent {}
func (a *Agent) ProcessQuery() error {}

// 变量名：驼峰命名，有意义
var embeddingModel string
var maxRetries int

// 常量：大写，下划线分隔
const DefaultTimeout = 30 * time.Second
const MaxDocumentSize = 1024 * 1024
```

### 2. 注释规范
```go
// Package agent 实现了智能代理的核心功能
// 该包提供了RAG检索、MCP工具调用和对话管理的完整实现
package agent

// Agent 代表一个智能代理实例
// 它整合了聊天客户端、嵌入检索器和向量存储等组件
// 为用户提供统一的查询接口
type Agent struct {
    // chatClient 负责与大语言模型交互
    chatClient ChatClient
    
    // embeddingRetriever 处理文档嵌入和检索
    embeddingRetriever EmbeddingRetriever
}

// NewAgent 创建一个新的智能代理实例
// 参数：
//   - config: 代理配置信息
//   - chatClient: 聊天客户端实例
//   - embeddingRetriever: 嵌入检索器实例
// 返回：
//   - *Agent: 代理实例
func NewAgent(config AgentConfig, chatClient ChatClient, embeddingRetriever EmbeddingRetriever) *Agent {
    // 实现代码...
}
```

### 3. 错误处理
```go
// 使用有意义的错误信息
func (a *Agent) Query(ctx context.Context, query string) (*ChatResponse, error) {
    if query == "" {
        return nil, fmt.Errorf("query cannot be empty")
    }
    
    // 包装底层错误
    response, err := a.chatClient.Chat(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("failed to get chat response: %w", err)
    }
    
    return response, nil
}

// 定义自定义错误类型
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation error in field %s: %s", e.Field, e.Message)
}
```

### 4. 测试规范
```go
// 测试文件命名：*_test.go
// 测试函数命名：TestXxx

func TestAgent_Query(t *testing.T) {
    // 使用表驱动测试
    tests := []struct {
        name    string
        query   string
        want    *ChatResponse
        wantErr bool
    }{
        {
            name:    "valid query",
            query:   "Hello",
            want:    &ChatResponse{Content: "Hi there!"},
            wantErr: false,
        },
        {
            name:    "empty query",
            query:   "",
            want:    nil,
            wantErr: true,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // 创建测试实例
            agent := setupTestAgent(t)
            
            // 执行测试
            got, err := agent.Query(context.Background(), tt.query)
            
            // 验证结果
            if (err != nil) != tt.wantErr {
                t.Errorf("Query() error = %v, wantErr %v", err, tt.wantErr)
                return
            }
            if !reflect.DeepEqual(got, tt.want) {
                t.Errorf("Query() = %v, want %v", got, tt.want)
            }
        })
    }
}

// 辅助函数
func setupTestAgent(t *testing.T) *Agent {
    // 创建mock对象
    mockChat := &MockChatClient{}
    mockEmbedding := &MockEmbeddingRetriever{}
    mockVector := &MockVectorStore{}
    
    return NewAgent(AgentConfig{}, mockChat, mockEmbedding, mockVector)
}
```

## 添加新功能

### 1. 添加新的API服务商

#### 步骤1：扩展配置
```go
// internal/config/config.go
type OpenAIConfig struct {
    APIKey   string `json:"api_key"`
    BaseURL  string `json:"base_url"`
    Model    string `json:"model"`
    Provider string `json:"provider"` // 新增：服务商标识
}
```

#### 步骤2：实现适配器
```go
// internal/chat/providers/
// 创建新的服务商适配器
type CustomProvider struct {
    apiKey  string
    baseURL string
    client  *http.Client
}

func (p *CustomProvider) Chat(ctx context.Context, messages []Message) (*Response, error) {
    // 实现自定义API调用逻辑
}
```

#### 步骤3：注册服务商
```go
// internal/chat/factory.go
func NewChatClient(config OpenAIConfig) (ChatClient, error) {
    switch config.Provider {
    case "openai":
        return NewOpenAIClient(config)
    case "custom":
        return NewCustomProvider(config)
    default:
        return NewOpenAIClient(config) // 默认
    }
}
```

### 2. 添加新的向量存储后端

#### 步骤1：实现接口
```go
// internal/vectorstore/redis.go
type RedisVectorStore struct {
    client *redis.Client
    index  string
}

func (r *RedisVectorStore) AddEmbedding(embedding []float64, document string) error {
    // 实现Redis存储逻辑
}

func (r *RedisVectorStore) Search(queryEmbedding []float64, k int) ([]VectorStoreItem, error) {
    // 实现Redis搜索逻辑
}
```

#### 步骤2：添加配置
```env
# .env
VECTOR_STORE_TYPE=redis
REDIS_URL=redis://localhost:6379
REDIS_INDEX=embeddings
```

#### 步骤3：工厂模式
```go
// internal/vectorstore/factory.go
func NewVectorStore(storeType string, config map[string]string) (VectorStore, error) {
    switch storeType {
    case "memory":
        return NewInMemoryVectorStore(), nil
    case "redis":
        return NewRedisVectorStore(config)
    default:
        return nil, fmt.Errorf("unsupported vector store type: %s", storeType)
    }
}
```

### 3. 添加新的MCP工具

#### 步骤1：创建工具服务器
```javascript
// tools/weather-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';

const server = new Server({
    name: 'weather-server',
    version: '1.0.0',
});

server.setRequestHandler('tools/list', async () => ({
    tools: [{
        name: 'get_weather',
        description: '获取天气信息',
        inputSchema: {
            type: 'object',
            properties: {
                city: { type: 'string', description: '城市名称' }
            },
            required: ['city']
        }
    }]
}));

server.setRequestHandler('tools/call', async (request) => {
    const { name, arguments: args } = request.params;
    
    if (name === 'get_weather') {
        // 调用天气API
        const weather = await getWeatherData(args.city);
        return {
            content: [{
                type: 'text',
                text: `${args.city}的天气：${weather.description}，温度${weather.temperature}°C`
            }]
        };
    }
});
```

#### 步骤2：注册工具
```go
// cmd/main.go
func initializeMCPClients(ctx context.Context, agent *agent.Agent) error {
    mcpConfigs := []struct {
        name    string
        command string
        args    []string
    }{
        // 添加新工具
        {"weather", "node", []string{"tools/weather-server.js"}},
    }
    
    // 初始化逻辑...
}
```

## 测试策略

### 1. 单元测试
```bash
# 运行所有测试
go test ./...

# 运行特定包的测试
go test ./internal/agent

# 运行测试并生成覆盖率报告
go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out
```

### 2. 集成测试
```go
// tests/integration_test.go
func TestFullWorkflow(t *testing.T) {
    // 设置测试环境
    cfg := setupTestConfig(t)
    agent := setupTestAgent(t, cfg)
    
    // 添加测试文档
    docs := []string{"Go is a programming language."}
    err := agent.AddKnowledge(context.Background(), docs)
    require.NoError(t, err)
    
    // 测试查询
    response, err := agent.Query(context.Background(), "What is Go?")
    require.NoError(t, err)
    assert.Contains(t, response.Content, "programming language")
}
```

### 3. 性能测试
```go
// tests/benchmark_test.go
func BenchmarkAgent_Query(b *testing.B) {
    agent := setupBenchmarkAgent(b)
    query := "What is artificial intelligence?"
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := agent.Query(context.Background(), query)
        if err != nil {
            b.Fatal(err)
        }
    }
}

func BenchmarkVectorStore_Search(b *testing.B) {
    store := setupBenchmarkVectorStore(b)
    queryEmbedding := generateTestEmbedding()
    
    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        _, err := store.Search(queryEmbedding, 5)
        if err != nil {
            b.Fatal(err)
        }
    }
}
```

## 调试技巧

### 1. 日志调试
```go
// 使用结构化日志
import "log/slog"

func (a *Agent) Query(ctx context.Context, query string) (*ChatResponse, error) {
    slog.Info("Processing query", 
        "query", query,
        "user_id", getUserID(ctx),
        "timestamp", time.Now())
    
    // 处理逻辑...
    
    slog.Debug("Retrieved documents", 
        "count", len(docs),
        "similarity_scores", scores)
    
    return response, nil
}
```

### 2. 性能分析
```bash
# CPU性能分析
go test -cpuprofile=cpu.prof -bench=.
go tool pprof cpu.prof

# 内存分析
go test -memprofile=mem.prof -bench=.
go tool pprof mem.prof

# 运行时分析
go run -race cmd/main.go
```

### 3. 调试工具
```go
// 使用delve调试器
// 安装：go install github.com/go-delve/delve/cmd/dlv@latest

// 调试程序
dlv debug cmd/main.go

// 调试测试
dlv test ./internal/agent

// 远程调试
dlv debug --headless --listen=:2345 --api-version=2 cmd/main.go
```

## 部署指南

### 1. 构建优化
```bash
# 优化构建
go build -ldflags="-s -w" -o llm-mcp-rag cmd/main.go

# 交叉编译
GOOS=linux GOARCH=amd64 go build -o llm-mcp-rag-linux cmd/main.go
GOOS=windows GOARCH=amd64 go build -o llm-mcp-rag.exe cmd/main.go
```

### 2. Docker部署
```dockerfile
# Dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -ldflags="-s -w" -o llm-mcp-rag cmd/main.go

FROM alpine:latest
RUN apk --no-cache add ca-certificates nodejs npm
WORKDIR /root/

# 安装MCP工具
RUN npm install -g @modelcontextprotocol/server-filesystem

COPY --from=builder /app/llm-mcp-rag .
COPY --from=builder /app/knowledge ./knowledge

CMD ["./llm-mcp-rag"]
```

### 3. Kubernetes部署
```yaml
# k8s-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: llm-mcp-rag
spec:
  replicas: 3
  selector:
    matchLabels:
      app: llm-mcp-rag
  template:
    metadata:
      labels:
        app: llm-mcp-rag
    spec:
      containers:
      - name: llm-mcp-rag
        image: llm-mcp-rag:latest
        env:
        - name: OPENAI_API_KEY
          valueFrom:
            secretKeyRef:
              name: api-keys
              key: openai-key
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
```

## 贡献指南

### 1. 提交流程
```bash
# 1. Fork项目
# 2. 创建功能分支
git checkout -b feature/new-feature

# 3. 提交更改
git add .
git commit -m "feat: add new feature"

# 4. 推送分支
git push origin feature/new-feature

# 5. 创建Pull Request
```

### 2. 提交信息规范
```
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式化
refactor: 代码重构
test: 测试相关
chore: 构建过程或辅助工具的变动

示例：
feat: add support for Claude API
fix: resolve memory leak in vector store
docs: update API documentation
```

### 3. 代码审查清单
- [ ] 代码符合项目规范
- [ ] 添加了适当的测试
- [ ] 更新了相关文档
- [ ] 通过了所有测试
- [ ] 没有引入安全问题
- [ ] 性能影响可接受